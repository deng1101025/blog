"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4533],{5287:(e,l,t)=>{t.r(l),t.d(l,{data:()=>n});const n={key:"v-b20b14a2",path:"/assets/vue/sourceCodeAnalysis/",title:"从vue的生命周期学习vue的构建过程",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"组件渲染流程",slug:"组件渲染流程",children:[]},{level:2,title:"依赖草图",slug:"依赖草图",children:[]}],filePathRelative:"assets/vue/sourceCodeAnalysis/README.md",git:{updatedTime:163532618e4,contributors:[{name:"邓占伟",email:"332877552@qq.com",commits:1}]}}},5076:(e,l,t)=>{t.r(l),t.d(l,{default:()=>c});var n=t(6252),a=t(6780);const d=(0,n._)("h1",{id:"从vue的生命周期学习vue的构建过程",tabindex:"-1"},[(0,n._)("a",{class:"header-anchor",href:"#从vue的生命周期学习vue的构建过程","aria-hidden":"true"},"#"),(0,n.Uk)(" 从vue的生命周期学习vue的构建过程")],-1),u=(0,n._)("h2",{id:"组件渲染流程",tabindex:"-1"},[(0,n._)("a",{class:"header-anchor",href:"#组件渲染流程","aria-hidden":"true"},"#"),(0,n.Uk)(" 组件渲染流程")],-1),r=(0,n._)("p",null,"这种方式只能是同步的，不能像react一样实现并发，因为并发会导致当前watcher和当前依赖收集出现对不上的情况",-1),p=(0,n._)("ol",null,[(0,n._)("li",null,[(0,n._)("p",null,"构建ast，并缓存")]),(0,n._)("li",null,[(0,n._)("p",null,"通过执行mountComponent，构建一个updateComponent函数（ 函数内是 vm.update(vm.render()), 其中update是diff上树函数，render是生成vnode函数 ）")]),(0,n._)("li",null,[(0,n._)("p",null,"也是通过执行mountComponent，将当前watcher push到全局栈targetStack中，并把当前watcher赋值给全局的变量Dep.target，用于以来收集的时候使用（ 即，在dep.depend的时候使用 ）")]),(0,n._)("li",null,[(0,n._)("p",null,"生成vnode（ 每次执行的时候都是将缓存的ast和data进行合并生成新的vnode，可以有效提高性能，因为模板编译成ast很消耗性能，所以才进行缓存 ）")]),(0,n._)("li",null,[(0,n._)("p",null,"在生成vnode的时候会访问模板里面的响应式数据，即，触发依赖收集（ 执行dep.depend方法 ，depend方法中会访问 全局的Dep.target ， 并把当前的依赖收集的实例对象dep 通过全局watcher（ Dep.target ）的addDep push到 当前watcher上， 并且把当前watcher也 addSub到当前dep对象上 ， 这种双向的添加是为了让dep上也存在wathcer对象，方便，数据改变的时候通过dep.notify进行派发更新）")]),(0,n._)("li",null,[(0,n._)("p",null,"第5不是相互引用，watcher里面有deps。 deps里面有watcher， 有点像双向链表，但是不是纯正的双向链表")]),(0,n._)("li",null,[(0,n._)("p",null,"最后，首次会调用mountComponent，会new 一个Watcher实例，在构造函数中会调用watcher的get方法，")]),(0,n._)("li",null,[(0,n._)("p",null,"watcher的get方法作用就是执行 updateComponent方法")]),(0,n._)("li",null,[(0,n._)("p",null,"而updateComponent 方法 就是第2步说的 生成vnode，产生依赖收集，并返回vnode，最后执行update进行diff，上树")]),(0,n._)("li",null,[(0,n._)("p",null,"当修改data属性，会执行dep的notify方法，从notify")]),(0,n._)("li",null,[(0,n._)("p",null,"而notify方法的当前dep对象上是有保存watcher 列表的（ 这就得益于闭包和 前面 watcher和dep的相互引用的好处了 ），所以notify会循环执行watcher列表的update方法进行派发更新。")])],-1),i=(0,n._)("h2",{id:"依赖草图",tabindex:"-1"},[(0,n._)("a",{class:"header-anchor",href:"#依赖草图","aria-hidden":"true"},"#"),(0,n.Uk)(" 依赖草图")],-1),o=(0,n._)("p",null,"重点是依赖收集，派发更新",-1),s=(0,n._)("p",null,[(0,n._)("img",{src:a,alt:"vue草图"})],-1),h={},c=(0,t(3744).Z)(h,[["render",function(e,l){return(0,n.wg)(),(0,n.iD)(n.HY,null,[d,u,r,p,i,o,s],64)}]])},3744:(e,l)=>{l.Z=(e,l)=>{for(const[t,n]of l)e[t]=n;return e}},6780:(e,l,t)=>{e.exports=t.p+"assets/img/dep.56d0f0bb.png"}}]);